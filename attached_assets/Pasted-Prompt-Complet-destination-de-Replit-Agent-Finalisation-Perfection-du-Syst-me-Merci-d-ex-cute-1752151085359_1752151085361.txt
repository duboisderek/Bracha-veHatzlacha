Prompt Complet Ã  destination de Replit Agent â€“ Finalisation & Perfection du SystÃ¨me
Merci dâ€™exÃ©cuter les actions suivantes afin de finaliser la plateforme BrachaVeHatzlacha en corrigeant toutes les fonctionnalitÃ©s incomplÃ¨tes ou en attente, comme relevÃ© dans le rapport du 10 juillet 2025. Lâ€™objectif est dâ€™atteindre un niveau de stabilitÃ©, de propretÃ© de code, et de cohÃ©rence parfait, prÃªt pour un lancement en production sans comportement inattendu ni dÃ©pendance inactive.
ğŸ”§ 1. Redis (production) â€“ Configuration rÃ©elle
ProblÃ¨me actuel : Le systÃ¨me utilise un fallback local car aucune instance Redis rÃ©elle nâ€™est connectÃ©e.
Action demandÃ©e :
Connecter une instance Redis rÃ©elle (exemple : Upstash, Redis Cloud, ou Redis via Railway).
Ajouter la variable dâ€™environnement REDIS_URL dans le .env ou la configuration Replit.
Modifier le backend pour s'assurer que :
Les sessions utilisateurs sont bien stockÃ©es en Redis.
Toutes les fonctionnalitÃ©s utilisant un cache (auth, API throttling, tokens, notifications...) lâ€™utilisent via Redis.
But final : AmÃ©liorer les performances du backend et Ã©viter la surcharge inutile de la base de donnÃ©es PostgreSQL.
ğŸ”§ 2. Paiements Crypto â€“ Automatisation ou gestion sÃ©curisÃ©e
ProblÃ¨me actuel : Les paiements en crypto nÃ©cessitent une validation manuelle via lâ€™admin. Ce nâ€™est pas optimal ni automatisÃ©.
Action demandÃ©e :
ImplÃ©menter un systÃ¨me de validation automatisÃ©e des paiements crypto :
Soit en interfaÃ§ant directement lâ€™API dâ€™un wallet (Metamask, Coinbase, Binance, etc.).
Soit via lâ€™Ã©coute de webhooks de transactions (par exemple via un service tiers comme Blockonomics, NOWPayments, etc.).
Si lâ€™automatisation nâ€™est pas envisageable immÃ©diatement, alors :
CrÃ©er un systÃ¨me de logs dÃ©taillÃ©s des paiements en attente.
Afficher un statut transaction (en attente, confirmÃ©, refusÃ©) dans lâ€™interface admin.
Envoyer une notification Ã  lâ€™admin Ã  chaque nouveau paiement crypto Ã  valider.
But final : Rendre le systÃ¨me de paiement crypto fluide, traÃ§able et soit automatique, soit maÃ®trisÃ© avec rigueur.
ğŸ”§ 3. Backups â€“ Connexion rÃ©elle Ã  un service de stockage distant
ProblÃ¨me actuel : Une API de backup est codÃ©e, mais non connectÃ©e Ã  un espace de stockage rÃ©el.
Action demandÃ©e :
Connecter lâ€™API de sauvegarde automatique Ã  un service compatible avec Replit :
Par exemple : Replit Storage API, Firebase Storage, AWS S3, Cloudflare R2, etc.
Automatiser les sauvegardes de la base de donnÃ©es (PostgreSQL) avec une frÃ©quence hebdomadaire ou quotidienne via CRON.
Sauvegarder :
Les tables critiques (users, transactions, tickets, draws, etc.)
Les fichiers Ã©ventuels (upload ou images)
Logs systÃ¨me si disponibles
GÃ©nÃ©rer une alerte ou log aprÃ¨s chaque backup rÃ©ussi.
But final : Garantir la sÃ©curitÃ© des donnÃ©es avec des sauvegardes accessibles, rÃ©currentes et fiables.
ğŸ”§ 4. i18n â€“ Suppression des clÃ©s en double
ProblÃ¨me actuel : Le fichier i18n_final.ts contient des doublons de clÃ©s, provoquant des avertissements au build.
Action demandÃ©e :
Scanner le fichier i18n_final.ts et toutes ses variantes (FR, EN, HE).
Supprimer toutes les clÃ©s identiques dÃ©finies plusieurs fois (en conservant la plus rÃ©cente si doute).
Facultatif mais recommandÃ© : Ajouter un script (npm run lint:i18n) ou un check dans CI/CD pour Ã©viter les doublons Ã  lâ€™avenir.
But final : Avoir une structure i18n propre, sans conflits ni ambigÃ¼itÃ©s Ã  l'affichage.
ğŸ”§ 5. Redis (local dev) â€“ Fallback pour les dÃ©veloppeurs
ProblÃ¨me actuel : Redis nâ€™est pas utilisable localement, ce qui gÃªne les dÃ©veloppeurs en local.
Action demandÃ©e :
Modifier le code pour dÃ©tecter automatiquement lâ€™environnement local (par ex. via process.env.NODE_ENV === 'development').
Si Redis nâ€™est pas disponible, utiliser un fallback clair (en mÃ©moire, ou un cache JS).
Documenter cette configuration dans le fichier README.md avec instructions pour les dÃ©veloppeurs :
Comment installer Redis localement (optionnel)
Comment utiliser le fallback
Quelle limitation cela implique en mode local
But final : Assurer une expÃ©rience de dÃ©veloppement fluide sans casser les fonctionnalitÃ©s dÃ©pendant de Redis.
ğŸ”§ 6. Service Worker â€“ Activation en build production
ProblÃ¨me actuel : Le Service Worker est prÃ©sent mais dÃ©sactivÃ© en dÃ©veloppement, empÃªchant les tests de comportement offline.
Action demandÃ©e :
Activer le Service Worker dans les builds de production :
Par exemple : vite.config.ts doit appeler register() uniquement si import.meta.env.MODE === 'production'.
Permettre aux dÃ©veloppeurs de tester en local en lanÃ§ant un build de prod (npm run build && npm run preview).
Tester et valider :
Mise en cache des assets
DisponibilitÃ© offline de la page dâ€™accueil et de lâ€™espace client
Notification Ã©ventuelle en cas de nouvelle version
But final : Assurer que la plateforme fonctionne de maniÃ¨re fluide en PWA, mÃªme sans connexion.
ğŸ”§ 7. Suppression du cadeau de bienvenue automatique (bonus 100â‚ª)
ProblÃ¨me actuel : Ã€ chaque crÃ©ation de compte, un crÃ©dit automatique de 100â‚ª est accordÃ© â€” cette logique doit Ãªtre retirÃ©e.
Action demandÃ©e :
Supprimer entiÃ¨rement la logique qui ajoute un bonus de bienvenue Ã  tout nouvel utilisateur :
Code backend (dans le contrÃ´leur de crÃ©ation ou middleware utilisateur)
Code frontend (sâ€™il y a une mention visuelle du cadeau)
Sâ€™assurer que tout nouvel utilisateur a un solde initial de 0â‚ª sans bonus.
Supprimer tout test, toute notification, et toute traduction associÃ©e Ã  ce bonus.
But final : Revenir Ã  un modÃ¨le standard oÃ¹ lâ€™utilisateur dÃ©marre sans avantage par dÃ©faut.
ğŸ¯ Objectif global
Corriger ces 7 points techniques pour que la plateforme soit parfaitement propre, sans dÃ©pendances inactives, sans comportement temporaire, et entiÃ¨rement sous contrÃ´le technique, prÃªte Ã  Ãªtre auditÃ©e, testÃ©e et utilisÃ©e sans surprise.